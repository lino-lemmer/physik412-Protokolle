#!/usr/bin/python3
# -*- coding: utf-8 -*-

# Copyright © 2013 Martin Ueding <dev@martin-ueding.de>
# Licensed under The GNU Public License Version 2 (or later)

import jinja2
import logging
import math
import matplotlib.pyplot as pl
import numpy as np
import scipy.interpolate
import scipy.optimize as op
import sys
import unitprint

def lin_fit(x, a, b):
    return a * x + b

def Stromkennlinie(T, filename, save):
    # Daten einlesen.
    data = np.genfromtxt(filename)
    data = data[data[:,1].argsort()]

    # Daten berechnen.
    I_0 = data[0,1]*1e-10
    dI_0 = data[0,3]*1e-10
    U = -data[1:,0]
    dU = data[1:,2]
    I = data[1:,1]*1e-10
    dI = data[1:,3]*1e-10
    sqrt_I = np.sqrt(I-I_0)
    dsqrt_I = np.sqrt((dI/(2*np.sqrt(I-I_0)))**2+(dI_0/(2*np.sqrt(I-I_0)))**2)

    # Messwerte interpolieren
    popt, pconv = op.curve_fit(lin_fit, U, sqrt_I)
    x = np.linspace(np.min(U), np.max(U), 100)
    y = lin_fit(x, *popt)

    p_err = np.sqrt(pconv.diagonal())

    # Messwerte plotten
    pl.errorbar(U, sqrt_I, xerr=dU, yerr=dsqrt_I, linestyle="none", marker="x")
    pl.plot(x, y)
    pl.xlabel(r"$U / \mathrm{V}$")
    pl.ylabel(r"$\sqrt{I-I_0} / \sqrt{\mathrm{nA}}$")
    pl.grid(True)
    pl.savefig(save)
    pl.clf()
#
#    # Nullstelle Berechnen
    def nullstelle(x):
        return lin_fit(x, *popt)

    return op.fsolve(nullstelle, 0)

def kennlinien(T):

    wavelength = (365e-9, 405e-9, 436e-9, 546e-9, 578e-9)
    U_0 = (Stromkennlinie(T, "Messwerte/Kennlinie_365.txt","_build/Plot-365.pdf"), Stromkennlinie(T, "Messwerte/Kennlinie_405.txt","_build/Plot-405.pdf"), Stromkennlinie(T, "Messwerte/Kennlinie_436.txt","_build/Plot-436.pdf"), Stromkennlinie(T, "Messwerte/Kennlinie_546.txt","_build/Plot-546.pdf"),  Stromkennlinie(T, "Messwerte/Kennlinie_578.txt","_build/Plot-578.pdf"))

    print(U_0)

    # Kennlinie U_0 gegen Frequenz

def render_template(T, filename):
    # Setting up Jinja
    env = jinja2.Environment(
        "%<", ">%",
        "<<", ">>",
        "%§", "§%",
        loader=jinja2.FileSystemLoader(".")
    )
    template = env.get_template("Template.tex")

    logging.info("Writing to “{}”".format(filename))

    # Rendering LaTeX document with values.
    with open(filename, "w") as f:
        f.write(template.render(**T))

def main():
    T = {}

    logging.basicConfig(level=logging.INFO)

    kennlinien(T)

    #render_template(T, sys.argv[1])

if __name__ == "__main__":
    main()
