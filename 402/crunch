#!/usr/bin/python3
# -*- coding: utf-8 -*-

# Copyright © 2013 Martin Ueding <dev@martin-ueding.de>
# Licensed under The GNU Public License Version 2 (or later)

import jinja2
import logging
import math
import matplotlib.pyplot as pl
import numpy as np
import os.path
import scipy.interpolate
import scipy.optimize as op
import sys
import unitprint

def lin_fit(x, a, b):
    return a * x + b

def Stromkennlinie(T, filename, I_0, dI_0):
    # Daten einlesen.
    data = np.genfromtxt(filename)
    data = data[data[:,0].argsort()]

    # Daten berechnen.
    U = data[:,0]
    dU = data[:,2]
    I = data[:,1]
    dI = data[:,3]
    sqrt_I = np.sqrt(I-I_0)
    dsqrt_I = np.sqrt((dI/(2*np.sqrt(I-I_0)))**2+(dI_0/(2*np.sqrt(I-I_0)))**2)

    # Messwerte interpolieren
    popt, pconv = op.curve_fit(lin_fit, U, sqrt_I)
    x = np.linspace(np.min(U), np.max(U), 100)
    y = lin_fit(x, *popt)

    p_err = np.sqrt(pconv.diagonal())

    #TODO Nullstelle berechnen

    # Messwerte plotten
    pl.errorbar(U, sqrt_I, xerr=dU, yerr=dsqrt_I, linestyle="none", marker="x")
    pl.plot(x, y)
    pl.xlabel(r"$U / \mathrm{V}$")
    pl.ylabel(r"$\sqrt{I-I_0} / \sqrt{\mathrm{nA}}$")
    pl.grid(True)

def kennlinien(T):

    wavelength = [375e-9]
    I_0 = -2.03
    dI_0 = 0.02
    Stromkennlinie(T, "Messwerte/Kennlinie_365.txt", I_0, dI_0)
    pl.savefig("_build/Plot-365.pdf")
    pl.clf()

    wavelength.append(405e-9)
    I_0 = -2.03
    dI_0 = 0.02
    Stromkennlinie(T, "Messwerte/Kennlinie_405.txt", I_0, dI_0)
    pl.savefig("_build/Plot-405.pdf")
    pl.clf()

    wavelength.append(435e-9)
    I_0 = -2.03
    dI_0 = 0.02
    Stromkennlinie(T, "Messwerte/Kennlinie_435.txt", I_0, dI_0)
    pl.savefig("_build/Plot-435.pdf")
    pl.clf()

    wavelength.append(545-9)
    I_0 = -2.03
    dI_0 = 0.02
    Stromkennlinie(T, "Messwerte/Kennlinie_545.txt", I_0, dI_0)
    pl.savefig("_build/Plot-545.pdf")
    pl.clf()

    wavelength.append(578-9)
    I_0 = -2.03
    dI_0 = 0.02
    Stromkennlinie(T, "Messwerte/Kennlinie_578.txt", I_0, dI_0)
    pl.savefig("_build/Plot-578.pdf")
    pl.clf()

def wavelength_U0(T):

    pl.plot(wavelength, U_0, linestyle="none", marker="x")

def balmer_serie(T):
    omega_B_val = 145
    omega_B_err = .1

    T["omega_B"] = "145.0 +- .1"

    farbe = []
    omega_G = []
    rel_int = []
    with open("Messwerte/Quecksilber.txt") as f:
        for line in f:
            if line.startswith("#"):
                continue
            x = line.split()
            farbe.append(x[0])
            omega_G.append(float(x[1]))
            rel_int.append(float(x[2]))

    lambda_ = np.array([
        690.752,
        671.643,
        623.440,
        579.066,
        576.960,
        546.074,
        491.607,
        491.607,
        435.833,
        433.922,
        404.656,
    ])

    T["omega_G_err"] = .2
    T["messdaten_gitterkonstante"] = np.column_stack([farbe, omega_G, rel_int, lambda_])

    omega_B_val = np.radians(omega_B_val)
    omega_B_err = np.radians(omega_B_err)
    omega_G_val = np.radians(omega_G)
    omega_G_err = np.ones(omega_G_val.size) * np.radians(.2)
    lambda_ *= 1e-9

    g_val = lambda_ / (np.sin(omega_G_val) - np.sin(omega_B_val + omega_G_val))
    g_err = g_val**2 / lambda_ * np.sqrt(
        ((np.cos(omega_G_val) - np.cos(omega_B_val + omega_G_val)) * omega_G_err)**2
        + (np.cos(omega_B_val + omega_G_val) * omega_B_err)**2
    )

    T["tabelle_gitterkonstante"] = np.column_stack([
        unitprint.siunitx(omega_G_val, np.ones(omega_G_val.size) * omega_G_err),
        unitprint.siunitx(lambda_),
        unitprint.siunitx(g_val, g_err),
    ])

    g_mean_val = np.mean(g_val)
    g_mean_err = np.sqrt(np.average(g_err**2)) / np.sqrt(len(g_val))

    g_average_val = np.average(g_val, weights=1/g_err)
    g_average_err = np.sqrt(np.average(g_err**2, weights=1/g_err)) / np.sqrt(len(g_val))

    T["g_mean"] = unitprint.siunitx(g_mean_val, g_mean_err)
    T["g_average"] = unitprint.siunitx(g_average_val, g_average_err)

    pl.errorbar(lambda_, g_val, yerr=g_err, linestyle='none', marker='+')
    pl.xlabel(r'$\lambda / \mathrm{m}$')
    pl.ylabel(r'$g / \mathrm{m}$')
    pl.grid(True)
    pl.savefig('_build/g.pdf')
    pl.clf()

    farbe = []
    omega_G = []
    rel_int = []
    with open("Messwerte/Ballmer.txt") as f:
        for line in f:
            if line.startswith("#"):
                continue
            x = line.split()
            farbe.append(x[0])
            omega_G.append(float(x[1]))
            rel_int.append(float(x[2]))

    T["messdaten_balmer"] = np.column_stack([farbe, omega_G, rel_int])
    omega_G_val = np.radians(omega_G)
    omega_G_err = np.ones(omega_G_val.size) * np.radians(.2)

    lambda_val = np.abs(g_average_val * (np.sin(omega_G_val) - np.sin(omega_B_val + omega_G_val)))
    lambda_err = np.sqrt(
        (lambda_val / g_average_val * g_average_err)**2
        + (g_average_val * (np.cos(omega_G_val) - np.cos(omega_B_val + omega_G_val)) * omega_G_err)**2
        + (g_average_val * np.cos(omega_G_val + omega_B_val) * omega_B_err)**2
    )

    T["tabelle_balmer"] = zip(farbe, unitprint.siunitx(omega_G_val, omega_G_err), rel_int, unitprint.siunitx(lambda_val, lambda_err))

    lambda_erwartet = np.array([3e8 * 6.626e-34 / (13.6*1.609e-19) * (1/4 - 1/n**2) for n in range(3, 10)])
    print(lambda_erwartet)

    T["balmer_berechnet"] = np.round(lambda_erwartet * 10**9, 1)

def pc_aufnahme(T):
    sets = [
        ('rot'),
        ('rot2'),
        ('gruen'),
        ('cyan'),
        ('cyan2'),
        ('blau'),
    ]

    for filename in sets:
        data = np.genfromtxt(os.path.join('Messwerte', filename+'.txt'))
        alpha = data[:, 0]
        intens = data[:, 1]

        pl.plot(alpha, intens, linestyle='none', marker='.', markersize=4)
        pl.grid(True)
        pl.title(filename)
        pl.xlabel(r'$\alpha / ^{\circ}$')
        pl.ylabel(r'relative Intensität')
        pl.savefig(os.path.join('_build', filename+'.pdf'))
        pl.clf()

        T["pc_"+filename] = list(zip(alpha, intens))

def render_template(T, filename):
    # Setting up Jinja
    env = jinja2.Environment(
        "%<", ">%",
        "<<", ">>",
        "%§", "§%",
        loader=jinja2.FileSystemLoader(".")
    )
    template = env.get_template("Template.tex")

    logging.info("Writing to “{}”".format(filename))

    # Rendering LaTeX document with values.
    with open(filename, "w") as f:
        f.write(template.render(**T))

def main():
    T = {}

    logging.basicConfig(level=logging.INFO)

    #kennlinien(T)

    balmer_serie(T)
    pc_aufnahme(T)

    render_template(T, sys.argv[1])

if __name__ == "__main__":
    main()
