#!/usr/bin/python3
# -*- coding: utf-8 -*-

# Copyright © 2013 Martin Ueding <dev@martin-ueding.de>
# Licensed under The GNU Public License Version 2 (or later)

#import scipy.interpolate
import glob
import json
import matplotlib.pyplot as pl
import colorsys
import multiprocessing
import pprint
import numpy as np
import re
import scipy.optimize as op
import scipy.signal
import sys
import unitprint

savefig_options = {
    'bbox_inches': 'tight',
}

def coloriter(n):
    return iter([
        colorsys.hsv_to_rgb(x*1.0/n, 1.0, .8)
        for x in range(n)
    ])

def polynom(x, a, b, c, d):
    return a + b*x + c*x**2 + d*x**3

def gauss(x, m, s, a):
    return a * np.exp(- 0.5 * ((x - m)/s)**2)

def tripple_gauss(x, m1, s1, a1, m2, s2, a2, m3, s3, a3, offset):
    return gauss(x, m1, s1, a1) + gauss(x, m2, s2, a2) + gauss(x, m3, s3, a3) + offset

def magnetfeldkalibrierung(T):
    data = np.genfromtxt('Messdaten/Magnetfeldkalibrierung_1.txt', skip_header=1)
    I = data[:, 2]
    B = data[:, 1] * 10**-3

    used = I < 8

    I_used = I[used]
    B_used = B[used]

    popt, pconv = op.curve_fit(polynom, I_used, B_used)
    fit_x = np.linspace(np.min(I_used), np.max(I_used))
    fit_y = polynom(fit_x, *popt)

    pl.plot(I_used, B_used, linestyle='none', marker='+', label='Messdaten')
    pl.plot(fit_x, fit_y, label='Anpassung')
    pl.xlabel(r'$I / \mathrm{A}$')
    pl.ylabel(r'$B / \mathrm{T}$')
    pl.legend(loc='best')
    pl.grid(True)
    pl.savefig('_build/Magnetfeldkalibrierung.pdf', **savefig_options)
    pl.clf()

    return lambda I: polynom(I, *popt)

def job_zeeman(T):
    B = magnetfeldkalibrierung(T)

    d = 4e-3
    n = 1.457

    lambda_cd = 6438.470e-10

    m_max = np.round(2 * n * d / lambda_cd)

    print('m_max', m_max)

    files = glob.glob('Messdaten/Mit_*.txt')
    pattern = re.compile('Messdaten/Mit_(\d+(.\d+)?).txt')
    data = {}
    for file_ in files:
        m = pattern.match(file_)
        if m:
            I = float(m.group(1))

        file_content = np.genfromtxt(file_, skip_header=1)
        alpha = np.radians(file_content[:, 0])
        intens = file_content[:, 1]
        cut = alpha < 0
        alpha = alpha[cut]
        intens = intens[cut]
        lambda_ =  2 * n * d * np.cos(alpha) / (m_max - 1)

        data[I] = (lambda_, intens)

    alles_fig = pl.figure()
    zoom_fig = pl.figure()
    alles = alles_fig.add_subplot(1, 1, 1)
    zoom = zoom_fig.add_subplot(1, 1, 1)

    citer = coloriter(len(data))

    for I, (lambda_, intens) in sorted(data.items()):
        color = next(citer)
        label = r'$B = {:.2g} \, \mathrm{{cT}}$'.format(B(I) * 100)
        alles.plot(lambda_ / 10**-9, intens, label=label, color=color)
        selection = lambda_[6.4375e-7 < lambda_] < 6.440e-7
        zoom.plot(lambda_[selection] / 10**-7, intens[selection], label=label, color=color)

    T['I_list'] = [str(x).replace('.', ',') for x in sorted(data.keys())]

    T['B_dict'] = {I_: B(I_) for I_ in data.keys()}

    alles.set_xlabel(r'$\lambda / ^\circ$')
    alles.set_ylabel(r'rel. Int.')
    alles.legend(loc='best')
    alles.grid(True)
    alles_fig.savefig('_build/Alles.pdf', **savefig_options)

    zoom.set_xlabel(r'$\lambda / m$')
    zoom.set_ylabel(r'rel. Int.')
    #zoom.legend(loc='best')
    zoom.grid(True)
    zoom_fig.savefig('_build/Zoom.pdf', **savefig_options)

    fit_ergebnisse = []

    fit_ergebnisse.append(einzel_fit(
        data, 0.0, 6.4375e-7, 6.4400e-7,
        [-0.91, 0.05, 0.5, -0.83, 0.04, 15, -0.74, 0.04, 7, 23]
    ))

    fit_ergebnisse.append(einzel_fit(
        data, 1.0, 6.4375e-7, 6.4400e-7,
        [-0.91, 0.05, 0.5, -0.83, 0.04, 15, -0.74, 0.04, 7, 23]
    ))

    fit_ergebnisse.append(einzel_fit(
        data, 2.0, 6.4375e-7, 6.4400e-7,
        [-0.91, 0.05, 0.5, -0.83, 0.04, 15, -0.74, 0.04, 7, 23]
    ))

    fit_ergebnisse.append(einzel_fit(
        data, 3.0, 6.4375e-7, 6.4400e-7,
        [-0.90, 0.05, 15, -0.83, 0.04, 27, -0.76, 0.04, 20, 10]
    ))

    fit_ergebnisse.append(einzel_fit(
        data, 4.0, 6.4375e-7, 6.4400e-7,
        [-0.91, 0.05, 0.5, -0.83, 0.04, 15, -0.74, 0.04, 7, 23]
    ))

    fit_ergebnisse.append(einzel_fit(
        data, 4.5, 6.4375e-7, 6.4400e-7,
        [-0.91, 0.05, 0.5, -0.83, 0.04, 15, -0.74, 0.04, 7, 23]
    ))

    fit_ergebnisse.append(einzel_fit(
        data, 5.0, 6.43782e-7, 6.43821e-7,
        [6.43783e-7, 3e-12, 4, 6.43804e-7, 4e-12, 20, 6.4382e-7, 3.5e-12, 10, 20]
    ))

    fit_ergebnisse.append(einzel_fit(
        data, 5.5, 6.4378e-7, 6.43829e-7,
        [6.43783e-7, 3e-12, 3, 6.43804e-7, 4e-12, 20, 6.4382e-7, 3.5e-12, 10, 20]
    ))

    fit_ergebnisse.append(einzel_fit(
        data, 6.0, 6.4378e-7, 6.43829e-7,
        [6.43783e-7, 3e-12, 3, 6.43804e-7, 4e-12, 20, 6.4382e-7, 3.5e-12, 10, 20]
    ))

    fit_ergebnisse.append(einzel_fit(
        data, 7.0, 6.43776e-7, 6.43831e-7,
        [6.43781e-7, 3e-12, 7, 6.43804e-7, 4e-12, 26, 6.43825e-7, 4e-12, 13, 20]
    ))

    fit_ergebnisse.append(einzel_fit(
        data, 8.0, 6.43768e-7, 6.43837e-7,
        [6.43779e-7, 3e-12, 7, 6.43804e-7, 4e-12, 26, 6.43828e-7, 2e-12, 15, 20]
    ))

    fit_ergebnisse = np.array([x for x in fit_ergebnisse if x is not None])

    print('fit_ergebnisse')
    print(fit_ergebnisse)

    #fit_aufspaltungen(fit_ergebnisse)

def fit_aufspaltungen(fe):
    I = fe[:, 0]

def einzel_fit(data, I, min_, max_, p0):

    lambda_ = data[I][0]
    intens = data[I][1]

    selected = lambda_[min_ < lambda_] < max_

    lambda_selected = lambda_[selected]
    intens_selected = intens[selected]

    print('lambda_selected', lambda_selected)
    print('intens_selected', intens_selected)

    p = pl.figure()
    a = p.add_subplot(1, 1, 1)
    a.plot(lambda_selected / 10**-7, intens_selected, linestyle='none', marker='+', label='Daten')

    returnval = None

    try:
        popt, pconv = op.curve_fit(tripple_gauss, lambda_selected, intens_selected, p0=p0)
        x = np.linspace(np.min(lambda_selected), np.max(lambda_selected), 1000)
        a.plot(x / 10**-7, tripple_gauss(x, *popt), label='Anpassung')
        a.plot(x / 10**-7, gauss(x, *popt[0:3]), label='Summand 1', linestyle='--')
        a.plot(x / 10**-7, gauss(x, *popt[3:6]), label='Summand 2', linestyle='--')
        a.plot(x / 10**-7, gauss(x, *popt[6:9]), label='Summand 3', linestyle='--')
        a.plot(x / 10**-7, np.ones(x.size) * popt[9], label='Untergrund', linestyle='--')

        print(popt[0:3])
        print(popt[3:6])
        print(popt[6:9])
        print(popt[9])
        print(pconv)

        returnval = [I] + popt + np.sqrt(pconv.diagonal())
    except RuntimeError as e:
        print(e)
    except AttributeError as e:
        print(e)

    a.grid(True)
    a.legend(loc='best')
    #a.set_title(r'$I = {}$'.format(I))
    a.set_xlabel(r'$\lambda / ^\circ$')
    a.set_ylabel(r'rel. Int.')
    p.savefig('_build/Fit-{}.pdf'.format(str(I).replace('.', ',')))

    return returnval

def main():
    with multiprocessing.Manager() as manager:
        T = manager.dict()

        l = globals()
        to_run = []
        for key, value in l.items():
            if key.startswith('job_'):
                to_run.append(value)

        print('Will run the following functions:')
        for f in to_run:
            print('-', f)

        processes = []
        for f in to_run:
            p = multiprocessing.Process(target=f, args=(T,))
            print("Starting", p)
            p.start()
            processes.append(p)

        for p in processes:
            print("Waiting for", p)
            p.join()

        print("Serializing …")

        with open('_build/template.js', 'w') as f:
            json.dump(dict(T), f, indent=4, sort_keys=True)

if __name__ == "__main__":
    main()
